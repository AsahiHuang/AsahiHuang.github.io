{"pages":[],"posts":[{"title":"eva2020","text":"EVA 2020新剧场版 0706特别活动 EVA 2020年新剧场版 AVANT1 0706版将在2019.7.6首发 有意思的是,这一时间点正好与飞跃巅峰的结尾0706呼应","link":"/eva2020/"},{"title":"Thinkpad-P51-Hackintosh","text":"针对本机型在GitHub上传过一个EFI针对10.14.2https://github.com/AsahiHuang/ThinkPadP51-Hackintosh 目前已经更新到10.14.6，更新前注意更新clover版本，老版本alc睡眠唤醒会造成无声，请更新lilu组建，详细方法见上面链接 本机的主要配置信息： 设备 描述 CPU i7-7700HQ 显卡 HD630 屏幕 4k（京东方） 内存 16G 硬盘 sm961 如果你的机型和我差不多的话最方便的办法把下载的镜像写入u盘后直接替换我的EFI文件，注意包括序列号在内的SMBIOS信息已移除自行修改 至于说原生网卡的好处，配合aw解锁啦","link":"/Thinkpad-P51-Hackintosh/"},{"title":"git常用指令","text":"初始配置1234git config --global user.name &quot;username&quot;git config --global user.email &quot;email&quot;--global参数可以保证机器上所有的git仓库使用这个配置 然后输入 1ssh-keygen 分支 查看分支：git branch 创建分支：git branch name 切换分支：git checkout name 创建+切换分支：git checkout –b name 合并某分支到当前分支：git merge name 删除分支：git branch –d name 远程仓库(github) 创建ssh key github上add ssh key github上创建新的仓库 根据GitHub仓库链接 1git remote add origin https://github.com/AsahiHuang/Data_Structure.git 将本地仓库推送到远程仓库 ,git push,实际将当前分支推送到远程 由于远程库是空的，我们第一次推送master分支时，加上了 –u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。 现在,只要本地作提交,可通过 1git push origin master 把本地master分支的最新修改推送到GitHub 文件修改回退1git reset –hard HEAD~100 指向上次修改的指针 或者 1git checkout -- filename 把filename文件在工作区的修改全部撤销 这里有两种情况 文件自动修改后，还没有放到暂存区，使用 撤销修改就回到和版本库一模一样的状态。 另外一种是文件已经放入暂存区了，接着又作了修改，撤销修改就回到添加暂存区后的状态。 再没有commit前,通过此命令也可将删除的文件(rm filename)恢复 远程仓库克隆1git clone 远程仓库地址 即可在本地生成一个版本库 分支策略​ 常合并分支时，git一般使用”Fast forward”模式，在这种模式下，删除分支后，会丢掉分支信息，现在我们来使用带参数 –no-ff来禁用”Fast forward”模式 1git merge –-no-ff -m &quot;注释&quot; 合并分支 分支策略：首先master主分支应该是非常稳定的，也就是用来发布新版本，一般情况下不允许在上面干活，干活一般情况下在新建的dev分支上干活，干完后，比如上要发布，或者说dev分支代码稳定后可以合并到主分支master上来。 bug分支​ 在开发中，会经常碰到bug问题，那么有了bug就需要修复，在Git中，分支是很强大的，每个bug都可以通过一个临时分支来修复，修复完成后，合并分支，然后将临时的分支删除掉。比如我在开发中接到一个404 bug时候，我们可以创建一个404分支来修复它，但是当前的dev分支上的工作到一半还没有提交,此时无法切换分支. ​ Git提供了stash 功能,可以把当前的工作现场隐藏,等恢复现场后继续工作 1git stash 此时工作区的状态时干净的 切换回主分支,新建一个临时分支,修复完成后,回到主分支并合并,删除临时分支 现在回到dev分支 此时工作区时干净的,可通过 1git stash list 查看, Git把stash内容存在某个地方了，但是需要恢复一下,两种办法: git stash apply恢复，恢复后，stash内容并不删除，你需要使用命令git stash drop来删除 另一种方式是使用git stash pop,恢复的同时把stash内容也删除了。 历史 查看日志 1git log 修改日志 最近一次commit的修改: 1git commit --amend","link":"/git 常用指令/"},{"title":"夕阳无限好","text":"台风“利奇马”离开上海后南汇的夕阳 AsahiHuang2019.8.11南汇","link":"/夕阳无限好/"},{"title":"用hexo写博客","text":"安装1$ npm install -g hexo 在git bush中安装hexo 初始化新建一个hexo文件夹,用来存放所有代码. 1$ hexo init //初始化 hexo 会自动下载需要文件. 12hexo g //生成hexo s //启动本地服务 打开浏览器访问 http://localhost:4000 即可看到内容 修改主题​ 找到官方主题:https://hexo.io/themes/ 下载到hexo目录的theme文件下 1git clone #主题仓库地址* /theme 修改根目录的_config.yml 中的 theme: landsape 改为 *theme: #NewThemeName# * 如果出现莫名其妙问题可通过*hexo clean *来清理,在生成并发布 上传到GitHub1$ hexo d 首先,ssh key配置好,其次,配置_config.yml中有关deploy的部门: 1234deploy: type: git repository: git@github.com:#githubID#/#githubID#.github.io.git branch: master #内为替换内容,也就是你的GitHub用户名 其次还需要在git bash输入 1npm install hexo-deployer-git --save 现在输入*hexo d * 就会将本次有改动的代码全部提交,没有改动的不会 提交完成后原仓库内的文件都没了,存放在了source文件夹. 常用hexo 命令1234567hexo new &quot;postName&quot; #新建文章hexo new page &quot;pageName&quot; #新建页面hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server）hexo deploy #部署到GitHubhexo help # 查看帮助hexo version #查看Hexo的版本 1234hexo n == hexo newhexo g == hexo generatehexo s == hexo serverhexo d == hexo deploy 12hexo s -g #生成并本地预览hexo d -g #生成并上传 写博客在git bash定位到hexo的根目录 1$ hexo new &apos;my-first-blog&apos; hexo就会在*_posts *下生成相关的md文件,然后再markdown编辑器上编写 一般完整的格式: 123456789---title: postName #文章页面上的显示名称，一般是中文date: 2013-12-02 15:30:16 #文章生成时间，一般不改，当然也可以任意修改categories: 默认分类 #分类tags: [tag1,tag2,tag3] #文章标签，可空，多标签请用格式，注意:后面有个空格description: 附加一段文章摘要，字数最好在140字以内，会出现在meta的description里面---以下是正文 让博文列表不显示全部内容默认情况下,生成的目录会显示全部的文章内容,可以再合适的位置加上 1&lt;!--more--&gt; 即可 参考:https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html#%E4%BD%BF%E7%94%A8hexo%E5%86%99%E5%8D%9A%E5%AE%A2","link":"/用 hexo 写博客/"},{"title":"对于京都动画的不幸沉痛的悼念","text":"@AsahiHuang最後まで笑ってる強さをもう知っていた， もう泣かない…，もう泣かない…。感谢京阿尼，一切都会安好的 这已经不仅仅对于动画业界而言的一次沉痛灾难,我们失去了那么多用自己的心血和热情塑造一个个梦想的人，如今只能满怀悲痛的心为他们致以敬意，祝福每一位经历这场不幸的幸存者们早日康复，回到自己的幸福。 我相信京都动画一定能挺过这段艰难并继续将自己的优秀作品带给大家. AsahiHuang2019.7.24","link":"/对于京都动画的不幸沉痛的悼念/"},{"title":"摩尔投票算法","text":"起因刷leetcode_169 数组tag的时候有道题 给定一个大小为 n 的数组，找到其中的众数。众数是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。 你可以假设数组是非空的，并且给定的数组总是存在众数。 一般来讲大概第一反应是暴力算法,出现次数累加看谁超过了总数量的一半即可输出结果…方法可行可惜效率太低,时间复杂度达到O(n^2^),那有没有线性复杂度的解决办法. Boyer-Moore 投票算法少数服从多数的摩尔投票算法就是其中之一的解决之道 这里按照找众数的题来解释算法的实现过程: 1nums:[1,1,2,1,2,2,2,1,2] 比如说该数组nums,显然众数是 2 首先我们设置一个候选众数,初始为第一个元素nums[0] 我们设置一个计数器count,初始值为1,其规则是遇到与候选众数相同的数是+1,不同-1 当count值为0时,我们让候选众数变为下一位,并将count重置为1,继续上述规则 1[1,1,2,1,2 | 2,1,2] 分隔处为count归0时,此时候选众数变为下一位2,count值回到1 显然在这前面这一过程中,随着count值的递增递减到归0我们消耗了相同数量的非众数和众数 这是我认为投票算法最重要的思想,通过这样的往复,遍历结束后,最终候选众数即为该数组众数 代码实现附上本人用C实现上述例子: 1234567891011int majorityElement(int* nums, int numsSize){ int count = 0,res = nums[0]; int i = 0; while(i &lt; numsSize){ if (!count) res = nums[i]; count += (nums[i] == res ? 1:-1); i++; } return res;} AsahiHuang2019.7.5 at 530","link":"/摩尔投票算法/"},{"title":"用 oneindex 作图床","text":"自己的博客写文章最麻烦的莫过于图片的插入了，一个好的图床工具能减轻不少负担，本着勤俭节约（qiong）的原则，一直想找个免费的图床。 之前一直使用的 ipic+ 微博图床，虽免费好用，奈何只用了几次就挂了好几张。有考虑过用七牛云，免费10G空间，不过 https 不计入免费流量，后来因为个人版的 ondrive 送的30G要满了，加了个家庭车群想上车，这时候了解到了oneindex。oneindex 旨在将 onedrive 部署为个人的公盘，同时还可以作为在线的图床工具，正好我也有个vps，存储只有25G，加上还有个 office365 e3 的1T账户，等同于为我的vps扩容了，oneindex 内容的访问不计入vps的带宽，自带的图床工具虽然简单，但提供了三种引用格式。比不上ipic拖拽复制方便但也足够实用了(本文所有图片都来自 oneindex 的图床)，只是图片加载速度慢了点。 我的 oneindex 地址: https://pan.asahih.com/ 具体的部署方法参考：http://blog.lwc.im/2018/12/02/oneindex/ 还可以 Aria2+AriaNg 实现离线下载至 oneindex。 国内加载速度有些感人，而且图片时好时坏，有人说是微软限制的，也是人家微软也不是慈善家。 AsahiHuang2019.8.26","link":"/用 oneindex 作图床/"}],"tags":[{"name":"ACG","slug":"ACG","link":"/tags/ACG/"},{"name":"黑苹果","slug":"黑苹果","link":"/tags/黑苹果/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"随笔","slug":"随笔","link":"/tags/随笔/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"算法","slug":"算法","link":"/tags/算法/"},{"name":"oneindex","slug":"oneindex","link":"/tags/oneindex/"}],"categories":[]}