{"pages":[{"title":"About","text":"我感觉现在，离自己的梦想又近一步了！ 我&emsp;&emsp;现在是21岁的我。这20年里我与他人一样，学会了说话，学会了走路，学会了喜爱，学会了思考。许多人包括我在内都会厌恶昨天的自己，无知与幼稚。这是成长过程，或许十年后再来看学生时代会更加厌恶那时的自己吧。 &emsp;&emsp;生活中我能够意识到我的亲友，我的朋友他们对我的关怀与帮助。但我是一个很自私的人，因为我所表现的就是一在的索取，但真正轮到我付出却少之又少。我一直在想我欠他们太多了，或是我辜负他们了。其实那些真正爱你的人并不是想要得到所谓的回报，对于他们所表露出的真正的情感我却难以处理。所以我更倾向豪猪的哲学，寒冷的冬天，一群豪猪挤到一起取暖，但各自身上的刺迫使它们马上分开；御寒的本能使它们又聚到一起，疼痛则使它们再次分开。这样经过几次反复，它们终于找到了相隔的最佳距离，在最轻的疼痛下得到最大的温暖，只能自己蜷缩在一起，不用顾及他人。很明显这是一种逃避，就像我的高中语文老师指着我说的一个毫无责任感的人。 &emsp;&emsp;人是个很神奇的生物，我们继承了猴子的基因，猴子的手，但不知为什么，我们拥有了一个能够让我们理解理性与感性的大脑，同时却又拥有这不同的思维与性格。 目的&emsp;&emsp;这个 Blog 创建的目的是想记录自己学习新技术的过程，同时会夹带一些随笔或者自己喜欢的ACG圈的事情，毕竟文学功底不强写雅文什么的没这个水平。首先这些文章写完后是想展示给大家，因为技术水平不高，大佬什么完全不会care，但更多的其实是想写给自己。在学习的过程有了新的收获如果只是单纯作为一份笔记写下来，存在某个地方，可能不久就忘了放哪或者很少再想去回顾了。而将这种收获放在博客上给大家看时，即使可能根本没人关注，但自己也会更加细心处理其中细节，产出比随手的笔记更有价值的文章。当然最重要的还是能够坚持写下去啦。 理想&emsp;&emsp;搞开发。曾经有个学长问我你们想做开发的是不是都想赚很多钱，我当时回答至少我不是，他继续问那你是为了什么，去考个公务员或者教师或许更稳定舒服，我说我想去创造，这是我的理想。教资或者公务员或许是个不错选择，而且我不知道如果将理想变为工作会不会转为失望，但我认为从事一个自己毫无兴趣的事情只会永远无聊。活着当然是首要目标，只是我不想压抑的活着。 &emsp;&emsp;前几天参加了一位决心要带起我们学校ACM的老师举办的算法比赛，在座的很多大一新生，羡慕之情油然而生。他们还有更多时间能在校园，回看自己却浪费了太多时间。但我相信至少努力了还是会有收获的，不努力终究一无所得。最后希望自己能始终明白，当才华支撑不起自己理想时候，请安静地学习。 终。 2019.10.31Asahi Huang ​","link":"/about/index2.html"},{"title":"About","text":"我感觉现在，离自己的梦想又近一步了！ 目的&emsp;&emsp;这个 Blog 创建的目的是想记录自己学习新技术的过程，同时会夹带一些随笔或者自己喜欢的ACG圈的事情，毕竟文学功底不强写雅文什么的没这个水平。首先这些文章写完后是想展示给大家，因为技术水平不高，大佬什么完全不会care，但更多的其实是想写给自己。在学习的过程有了新的收获如果只是单纯作为一份笔记写下来，存在某个地方，可能不久就忘了放哪或者很少再想去回顾了。而将这种收获放在博客上给大家看时，即使可能根本没人关注，但自己也会更加细心处理其中细节，产出比随手的笔记更有价值的文章。当然最重要的还是能够坚持写下去啦。 2019.10.31Asahi Huang ​","link":"/about/index.html"},{"title":"categories","text":"","link":"/categories/index.html"}],"posts":[{"title":"22岁啦","text":"然后就没有了。","link":"/22岁啦/"},{"title":"E231系电车全部退出山手线运营","text":"“男人就像山手线，稍微等一会下一班就来了。” 高嶋知佐子 但你再也等不来E231了 什么是山手线 山手线（日语：山手線／やまのてせん Yamanote sen ）是位于日本东京的铁路线鐵路線，由东日本旅客铁道東日本旅客鐵道)（JR东日本）运营。做为运行系统的山手线。自1885年3月1日开业以来，山手线已发展为东京都心首要的公众运输动脉，现与都营大江户线并列为东京两大环城铁路。 山手線_维基百科 现运营车辆E231系500番台 运营时间2002-2020 E235系 运营时间2014-现在 山手线最后一辆E231系500番台与2020年1月10日最后运营。由1月11日起，山手线全线使用E235系。而退出运营的E231都会被刷黄用于中央总武线。 官方纪念活动运营方JR东日本为了纪念山手线上E231系的全部退出运营也将在2020年1月18日举行官方纪念活动，这种情怀感以及浓厚的铁道文化实在让人羡慕啊。我估计上海地铁老老八和西瓜退役的时候官方也会组织一下，特别是能加强与铁丝们的互动从而拉近之间的距离。 ​ AsahiHuang2020.1.13","link":"/E231系电车全部退出山手线运营/"},{"title":"ThinkpadP51 Catalina","text":"​ 之前有发过 Mojava 的版本，这次补上 Catalina ，EFI下载地址，关于其他信息说明可以参考 Mojava 的 repo，QQ讨论群：951898568 2019.11.25 更新到 Catalina 15.2 beta 19C46a Mojava 升级到 Catalina 注意​ 可能已经有所了解，Apple 这次是铁了心的要干掉32位软件，所以 Catalina 及之后版本都不可能再支持 32位软件，这导致原本许多应用特别是游戏都无法在新系统上运行，而唯一的解决办法是等软件更新支持或者在新系统上运行虚拟机跑 Mojava 环境，所以你需要权衡带来的影响。 sidecar 功能 ​ 这次更新的重点功能之一就是 sidecar 随航实现 iPad 上投屏，具体功能可在官网查询到，关与网卡因为我用的是原生网卡+转接卡，转接卡+原生网卡94360cs2 是放置在 WWAN 槽位（只有WWAN 位是足够放下 cs2，然后通过一条软排线连接一个标准 m.2 2230卡上。 其他​ 16寸的价格真香啊。。。不过还是更喜欢13寸（现在这个大家伙拿出去真的残念），下次一定买一台轻薄的，期待13寸的更新。下一台电脑一定 Mac 了。 2019.11.27Asahi Huang","link":"/ThinkpadP51-Catalina/"},{"title":"git常用指令","text":"初始配置1234git config --global user.name &quot;username&quot;git config --global user.email &quot;email&quot;--global参数可以保证机器上所有的git仓库使用这个配置 然后输入 1ssh-keygen 分支 查看分支：git branch 创建分支：git branch name 切换分支：git checkout name 创建+切换分支：git checkout –b name 合并某分支到当前分支：git merge name 删除分支：git branch –d name 远程仓库(github) 创建ssh key github上add ssh key github上创建新的仓库 根据GitHub仓库链接 1git remote add origin https://github.com/AsahiHuang/Data_Structure.git 将本地仓库推送到远程仓库 ,git push,实际将当前分支推送到远程 由于远程库是空的，我们第一次推送master分支时，加上了 –u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。 现在,只要本地作提交,可通过 1git push origin master 把本地master分支的最新修改推送到GitHub 文件修改回退1git reset –hard HEAD~100 指向上次修改的指针 或者 1git checkout -- filename 把filename文件在工作区的修改全部撤销 这里有两种情况 文件自动修改后，还没有放到暂存区，使用 撤销修改就回到和版本库一模一样的状态。 另外一种是文件已经放入暂存区了，接着又作了修改，撤销修改就回到添加暂存区后的状态。 再没有commit前,通过此命令也可将删除的文件(rm filename)恢复 远程仓库克隆1git clone 远程仓库地址 即可在本地生成一个版本库 分支策略​ 常合并分支时，git一般使用”Fast forward”模式，在这种模式下，删除分支后，会丢掉分支信息，现在我们来使用带参数 –no-ff来禁用”Fast forward”模式 1git merge –-no-ff -m &quot;注释&quot; 合并分支 分支策略：首先master主分支应该是非常稳定的，也就是用来发布新版本，一般情况下不允许在上面干活，干活一般情况下在新建的dev分支上干活，干完后，比如上要发布，或者说dev分支代码稳定后可以合并到主分支master上来。 bug分支​ 在开发中，会经常碰到bug问题，那么有了bug就需要修复，在Git中，分支是很强大的，每个bug都可以通过一个临时分支来修复，修复完成后，合并分支，然后将临时的分支删除掉。比如我在开发中接到一个404 bug时候，我们可以创建一个404分支来修复它，但是当前的dev分支上的工作到一半还没有提交,此时无法切换分支. ​ Git提供了stash 功能,可以把当前的工作现场隐藏,等恢复现场后继续工作 1git stash 此时工作区的状态时干净的 切换回主分支,新建一个临时分支,修复完成后,回到主分支并合并,删除临时分支 现在回到dev分支 此时工作区时干净的,可通过 1git stash list 查看, Git把stash内容存在某个地方了，但是需要恢复一下,两种办法: git stash apply恢复，恢复后，stash内容并不删除，你需要使用命令git stash drop来删除 另一种方式是使用git stash pop,恢复的同时把stash内容也删除了。 历史 查看日志 1git log 修改日志 最近一次commit的修改: 1git commit --amend","link":"/git 常用指令/"},{"title":"eva2020","text":"EVA 2020新剧场版 0706特别活动 EVA 2020年新剧场版 AVANT1 0706版将在2019.7.6首发 有意思的是,这一时间点正好与飞跃巅峰的结尾0706呼应","link":"/eva2020/"},{"title":"删除字符串中所有相邻重复项","text":"题目leetcode_1047 题目描述:给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。在 S 上反复执行重复项删除操作，直到无法继续删除。在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。 示例：输入：”abbaca”输出：”ca”解释：例如，在 “abbaca” 中，我们可以删除 “bb” 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 “aaca”，其中又只有 “aa” 可以执行重复项删除操作，所以最后的字符串为 “ca” 初步思路 将字符串转换成字符数组,创建一个 Stack 和一个空的字符串作为输出 判断传入字符串为空或只有一个字符时直接返回 将第一个字符入栈 从 i = 1 开始遍历,当栈不为空时,出栈一个字符和 a[i] 比较,如果相等为抵消不处理,如果不相等依次讲弹出的值和a[i]入栈 遍历栈,出栈剩余字符到 rs ,每个字符添加在 rs 之前并返回 1234567891011121314151617181920212223242526class Solution { public static String removeDuplicates(String S) { Stack&lt;Character&gt; stack = new Stack&lt;&gt;(); char[] a = S.toCharArray(); String rs = \"\"; if(a.length &lt;= 1) return rs + a[0]; stack.push(a[0]); for (int i = 1; i &lt; a.length;i++){ if (!stack.empty()){ char ch = stack.pop(); if (ch != a[i]){ stack.push(ch); stack.push(a[i]); } } else stack.push(a[i]); } while(!stack.empty()){ rs = stack.pop() + rs; } return rs; }} 官方解答官方解法并没有直接创建一个 Stack 而是模仿栈的功能处理 StringBuilder 12345678910111213public static String removeDuplicates(String S) { StringBuilder sb = new StringBuilder(); int sbLength = 0; for (char character : S.toCharArray()) { if (sbLength != 0 &amp;&amp; character == sb.charAt(sbLength - 1)) sb.deleteCharAt(sbLength-- - 1); //先删除末尾元素，再长度减一 else { sb.append(character); sbLength++; } } return sb.toString();} 果然还是差的太远了… 2019.11.21AsahiHuang","link":"/删除字符串中所有相邻重复项/"},{"title":"双栈法补全括号","text":"前言正好昨天是双十一,不知道大家都买了些什么.今年应我们老师的要求,十二期免息入手了一台卡西欧计算器…因为自己高中那台屏幕漏液了这次干脆就破费买了台功能多的. 第一次用卡西欧是在初中时候.之前接触的都是大家日常使用的那种普通计算器.可能还有”一 加 四 等于 五”还带喇叭,用上卡西欧后,就像发现了新大陆.因为它支持带括号计算了,题目上再多括号的嵌套只要正确它都能输入计算出结果.甚至支持带分式的处理得到结果也是分式.所以当年甚是好奇到底是怎么实现的其实用栈来处理就相当容易了 栈栈(stack)是一种遵循后进先出原则的数据结构.表尾是栈顶,表头则是栈底,其进栈(push)和出栈(pop)的操作都是在栈顶进行.我们在浏览网页时页面不停地跳转时,其中点击回退按钮后能够返回到上一页面的实现就是用到了栈的原理,计算机不停的将你当前浏览过的页面压入栈,在执行后退时在不停地弹出,这一顺序正好和你浏览过程相反. 这里不详细介绍栈的具体结构及实现方法,主要介绍双栈法 计算四则表达式E.W.Dijkstra发明了一个算法,通过两个栈来实现一个带括号的算术表达式求值. 规定表达式是由括号,运算符,数字构成的字符串,其中运算符也只考虑四种基本的+,-,*,/. 创建两个栈,一个数字栈(vals),一个符号栈(ops),分别用来存放数字和符号 12stack&lt;Double&gt; vals = new stack&lt;&gt;();stack&lt;String&gt; ops = new stack&lt;&gt;(); 遇到数字进数字栈 遇到运算符进符号栈 遇到左括号忽略 遇到右括号,分别在数字栈弹出两个数字,符号栈弹出一个符号进行计算,再将结果压入数字栈 最终数字栈只会留下最后一个值,就是该表达式的值,更加通用的处理方式还有将中序表达式转换成后序之后进行计算,这里不再展开. 补齐括号题目来自算法第四版的练习1.3.9,原题: 编写一段程序,从标准输入得到一个缺少左括号的表达式并打印出补全括号之后的中序表达式. 例如:给定输入: 1+2)*3-4)*5-6))) 你的程序应该输出: ((1+2))*((3-4)*(5-6)) 这个问题同样可以通过双栈法解决 和双栈法计算四则表达式一样,我们创建两个栈,分别存储数字和符号,不过现在我们不需要求值,而是直接输出补齐括号的表达式,所以我们数字栈也就改成存储字符串型 12Stack&lt;String&gt; vals = new Stack&lt;&gt;();Stack&lt;String&gt; opts = new Stack&lt;&gt;(); 我们这样规定 如果遇到符号,如”+,-,*,/“,压进符号栈 opts ,如果遇到数字,压进数字栈 vals 如果遇到”)”,分别弹出两位数字栈 vals 和一位符号栈 opts 进行拼接,然后将拼接后的字符串压回数字栈 vals 过程我们拿题目样例来演示这个过程1+2)*3-4)*5-6))) 前面3位的进栈没什么问题,接下来我们碰到了第一个”)”,按照我们的规则我们弹出数字栈的前两位以及符号栈的前一位进行一个拼接,红色部分就是栈中元素,同时在两端分别加上括号,形成一个新的字符串 同时我们将新的字符串压入到数字栈中 这部分对应代码,注意根据栈的后进先出原则,这里的先弹出n1是原表达式符号后的数字: 12345String n1 = vals.pop();String n2 = vals.pop();String opt = opts.pop();String data = \"(\" + n2 + opt + n1 + \")\";vals.push(data) 接下来程序继续走,走到了第二个待补全的右括号 进行和刚才一样的操作,拼接出一个新的字符串并压入数字栈 继续走,走到第三个待补全的右括号,此时后面全是右括号了, 相同处理后,现在的数字的栈元素都变成了带括号的字符串,后面的处理也是相同的,将它们看作一个数字与操作符做拼接 进行倒数第二次拼接,并压入数字栈 最后一个右括号我们把数字栈中剩下的两个字符串和符号栈中的最后一个符号做拼接,得到了补全了左括号后的完整表达式,现在只要弹出结果就行了 实现这里用的是 Java,主函数输出输出用的是算法四的函数 123456789101112131415161718192021222324252627282930import edu.princeton.cs.algs4.*;public class ex139{ public static String completeParentese(String in){ Stack&lt;String&gt; vals = new Stack&lt;&gt;(); Stack&lt;String&gt; opts = new Stack&lt;&gt;(); char[] s = in.toCharArray(); for (char ch : s){ if (ch == '*' || ch == '/' || ch == '+' || ch == '-'){ opts.push(String.valueOf(ch)); } else if (ch == ')'){ String n1 = vals.pop(); String n2 = vals.pop(); String opt = opts.pop(); String data = \"(\" + n2 + opt + n1 + \")\"; vals.push(data); } else vals.push(String.valueOf(ch)); } return vals.pop(); } public static void main(String[] args) { String st = StdIn.readString(); System.out.println(completeParentese(st)); }} AsahiHuang2019.11.12","link":"/双栈法补全括号/"},{"title":"单向链表的反转","text":"对单向链表的反转是非常经典的算法题，链表不同于数组，节点的遍历需要每个节点逐个访问下去。理解反转的过程能对线性表的链式存储结构有个充分的认识。为了方便理解（也为了防止自己日后忘了）所以尽可能仔细的记录其过程。 建表首先定义链表结构： 123456typedef struct Node{ int date; struct Node * next;} Node;typedef Node * LinkList; 创建一个链表 12345678910111213141516171819202122232425262728//n 描述了数据数组长度//尾插法LinkList creatListTail(LinkList L,int a[], int n){ LinkList p,r; L = (LinkList)malloc(sizeof(Node)); r = L; for (int i = 0 ; i &lt; n ;i++){ p = (LinkList)malloc(sizeof(Node)); p -&gt; date = a[i]; r -&gt; next = p; r = p; } r -&gt;next = NULL; return L;}//头插法LinkList creatListHead(LinkList L,int a[] ,int n){ LinkList p; L = (LinkList)malloc(sizeof(Node)); L -&gt; next = NULL; for (int i = 0; i &lt; n; i++){ p = (LinkList)malloc(sizeof(Node)); p -&gt;date = a[i]; p -&gt; next = L -&gt;next; L-&gt;next = p; } return L;} 一定要注意自己的建表方法，因为尾插法插入是按照数据顺序建表的，而头插法则是逆序。如果你没注意到而用头插法顺序插入数据然后反转当然又变成了顺序了。为了演示这边使用的是尾插法。同时补上头插法的代码，因为头插法的思想在这里非常重要 我们以一个长度为5数组来演示： 1a[5] = {1,2,3,4,5}; 我们得到了一个以L为头指针，包含了五个节点的单向链表 反转迭代法把这条链表想象成一个字符串，如果让你逆序一个字符串”Hello World”，你会怎么做？除了对半交换外，还有个方法是创建一个新的空间然后逆序存放原字符串的每个字符。 我们也是这样，首先创建一个新的头节点 ，就叫它 NewL。让他的后继节点为NULL，是不是有点像头插法建表步骤， 同时新建一个p指针指向L表的第一个节点，也就是p = L -&gt; next。 现在我们可以让 p -&gt; next指向 NewL？ 不可以，不同于头插法那时我们一直在生成新的p节点，现在如果直接让 p 的下一节点指向新的表尾，那我们就丢失了L表中 p -&gt; next，也就是p后继节点的位置，我们就没法遍历接下来的L表了，所以我们需要创建一个temp 来暂时存放p的后继节点，等到 p 也就是当前节点添加到新表完成后再让p回到temp继续。 我们先创建一个节点指针temp，让temp=p-&gt;next存储p的后继节点信息 接着我们就可以放心地让p指向新表的表尾（表尾是因为此时NewL还只是NULL） 12temp = p -&gt; next; //让temp存放p后驱节点p - &gt; next = NewL -&gt; next; //让p指向当前新表的后继 我们完成了一个节点的插入到新表，接下来我们要准备后续节点。首先我们让 NewL -&gt; next = p 从而使接下来的节点始终插入在新表头指针后面，如果你了解头插法你就会发现这一过程极其相似，为了实现逆序我们就是以原来的L表用头插法来创建一个新表，头插法本身就是逆置建表，让p回到temp后进入下次循环，新节点会不断的插入在表头后，直到L表结束。 12345//头插法部分：... p -&gt; next = L -&gt;next; //头插入中我们让新节点的后继指向头节点的后继 L-&gt;next = p //然后让头节点的后继变成新节点从而在中间不断插入... 12345//迭代法部分：... p -&gt;next = NewL -&gt; next; NewL -&gt; next = p;... NewL 头指针后继指向p（新插入节点） p移动到temp位置回来原表，准备下次循环直到NULL 代码实现： 12345678910111213141516LinkList reverse(LinkList L){ if (L == NULL || L -&gt; next == NULL){ return L; } LinkList p = L -&gt; next; LinkList NewL = (LinkList)malloc(sizeof(Node)); NewL -&gt; next = NULL; LinkList temp; while(p != NULL){ temp = p-&gt;next; p -&gt;next = NewL -&gt; next; NewL -&gt; next = p; p = temp; } return NewL;} 显示链表，注意这里链表都是有头节点 12345678910void display(LinkList L){ LinkList p; //指向第一个节点 p = L -&gt; next; while (p != NULL) { printf(\"%d\\n\",p-&gt;date); p = p -&gt; next; } } 基本上就是迭代法实现单链表反转的过程。 后面会再讲讲还有一种方法递归法。","link":"/单向链表的反转/"},{"title":"夕阳无限好","text":"台风“利奇马”离开上海后南汇的夕阳 AsahiHuang2019.8.11南汇","link":"/夕阳无限好/"},{"title":"对于京都动画的不幸沉痛的悼念","text":"@AsahiHuang最後まで笑ってる強さをもう知っていた， もう泣かない…，もう泣かない…。感谢京阿尼，一切都会安好的 这已经不仅仅对于动画业界而言的一次沉痛灾难,我们失去了那么多用自己的心血和热情塑造一个个梦想的人，如今只能满怀悲痛的心为他们致以敬意，祝福每一位经历这场不幸的幸存者们早日康复，回到自己的幸福。 我相信京都动画一定能挺过这段艰难并继续将自己的优秀作品带给大家. AsahiHuang2019.7.24","link":"/对于京都动画的不幸沉痛的悼念/"},{"title":"摩尔投票算法","text":"起因刷leetcode_169 数组tag的时候有道题 给定一个大小为 n 的数组，找到其中的众数。众数是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。 你可以假设数组是非空的，并且给定的数组总是存在众数。 一般来讲大概第一反应是暴力算法,出现次数累加看谁超过了总数量的一半即可输出结果…方法可行可惜效率太低,时间复杂度达到O(n^2^),那有没有线性复杂度的解决办法. Boyer-Moore 投票算法少数服从多数的摩尔投票算法就是其中之一的解决之道 这里按照找众数的题来解释算法的实现过程: 1nums:[1,1,2,1,2,2,2,1,2] 比如说该数组nums,显然众数是 2 首先我们设置一个候选众数,初始为第一个元素nums[0] 我们设置一个计数器count,初始值为1,其规则是遇到与候选众数相同的数是+1,不同-1 当count值为0时,我们让候选众数变为下一位,并将count重置为1,继续上述规则 1[1,1,2,1,2 | 2,1,2] 分隔处为count归0时,此时候选众数变为下一位2,count值回到1 显然在这前面这一过程中,随着count值的递增递减到归0我们消耗了相同数量的非众数和众数 这是我认为投票算法最重要的思想,通过这样的往复,遍历结束后,最终候选众数即为该数组众数 代码实现附上用C实现上述例子: 1234567891011int majorityElement(int* nums, int numsSize){ int count = 0,res = nums[0]; int i = 0; while(i &lt; numsSize){ if (!count) res = nums[i]; count += (nums[i] == res ? 1:-1); i++; } return res;} AsahiHuang2019.7.5 at 530","link":"/摩尔投票算法/"},{"title":"用hexo写博客","text":"安装1$ npm install -g hexo 在git bush中安装hexo 初始化新建一个hexo文件夹,用来存放所有代码. 1$ hexo init //初始化 hexo 会自动下载需要文件. 12hexo g //生成hexo s //启动本地服务 打开浏览器访问 http://localhost:4000 即可看到内容 修改主题​ 找到官方主题:https://hexo.io/themes/ 下载到hexo目录的theme文件下 1git clone #主题仓库地址* /theme 修改根目录的_config.yml 中的 theme: landsape 改为 *theme: #NewThemeName# * 如果出现莫名其妙问题可通过*hexo clean *来清理,在生成并发布 上传到GitHub1$ hexo d 首先,ssh key配置好,其次,配置_config.yml中有关deploy的部门: 1234deploy: type: git repository: git@github.com:#githubID#/#githubID#.github.io.git branch: master #内为替换内容,也就是你的GitHub用户名 其次还需要在git bash输入 1npm install hexo-deployer-git --save 现在输入*hexo d * 就会将本次有改动的代码全部提交,没有改动的不会 提交完成后原仓库内的文件都没了,存放在了source文件夹. 常用hexo 命令1234567hexo new &quot;postName&quot; #新建文章hexo new page &quot;pageName&quot; #新建页面hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server）hexo deploy #部署到GitHubhexo help # 查看帮助hexo version #查看Hexo的版本 1234hexo n == hexo newhexo g == hexo generatehexo s == hexo serverhexo d == hexo deploy 12hexo s -g #生成并本地预览hexo d -g #生成并上传 写博客在git bash定位到hexo的根目录 1$ hexo new &apos;my-first-blog&apos; hexo就会在*_posts *下生成相关的md文件,然后再markdown编辑器上编写 一般完整的格式: 123456789---title: postName #文章页面上的显示名称，一般是中文date: 2013-12-02 15:30:16 #文章生成时间，一般不改，当然也可以任意修改categories: 默认分类 #分类tags: [tag1,tag2,tag3] #文章标签，可空，多标签请用格式，注意:后面有个空格description: 附加一段文章摘要，字数最好在140字以内，会出现在meta的description里面---以下是正文 让博文列表不显示全部内容默认情况下,生成的目录会显示全部的文章内容,可以再合适的位置加上 1&lt;!--more--&gt; 即可 参考:https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html#%E4%BD%BF%E7%94%A8hexo%E5%86%99%E5%8D%9A%E5%AE%A2","link":"/用 hexo 写博客/"},{"title":"单向链表的反转(递归法)","text":"上次讲了通过迭代法 的方式，新建一个NewL倒叙插入原链表结点来实现反转，这次来讲递归法。 首先，什么是递归，去Google搜递归，会得到一个“你是不是要找递归”的提示，点开后还是这个页面。这就是递归。递归简单说就是函数调用自己。递归思想类似与栈，后入先出。这里重点讲讲递归实现单向链表的过程。 我们还是以这样一个五个元素的单链表为例，注意和之前一样演示的链表包含一个头结点L 1234567//链表的结构typedef struct Node{ int date; struct Node * next;} Node;typedef Node * LinkList; 递归递归需要出口，回想斐波拉契数列递归实现，我们的出口是当数字n==1 || n ==2 时，return 1;结束。对于一个单向链表来说，遍历到末尾NULL就是终点，同时考虑空表的情况，所以我们就有了递归的出口： 12345LinkList In_reverse(LinkList L){ if(L == NULL || L -&gt; next == NULL) return; ...} 递归的问题规模需要逐渐缩小，我们设置递归的前进条件，也就是遍历链表，新建一个新的头结点指针 NewL 让他等于递归结果。 12345... if(L == NULL || L -&gt; next == NULL) return; LinkList NewL = In_reverse(L -&gt; next);... 根据递归的出口条件，当 L -&gt; next == NULL时候返回，此时L就在5的位置，姑且称他为L=5的时候(而不是L指向5这个结点,指向5结点的是其前继4）。同时在递归结束前NewL也等于5，也就是说此时L，NewL都在最末尾的结点。同时因为递归调用已经结束，所以在接下来递归回退的过程中 LinkList NewL = In_reverse(L -&gt; next) 不会再执行，NewL始终留在原链表的最后结点。 既然递归结束了就要开始退回，根据后进先出的原则，首先回到的是L = 4的时候，开始执行递归调用后的代码 所以我们需要做什么？我们希望的结果是逆序原来的链表，现在的情况是我们创建的NewL已经牢牢地呆在原链表的最末尾也就最后新链表的开始，这正是我们想要的，所以我们只需要让4结点和5结点反一下指向不就实现了逆序。 为了实现反序，让后继的后继等于我，此时4结点和5结点是成环状态，互相指向对方。 代码实现上我们让5结点的next指向L，5结点也是4结点（同时也是现在的L）的后继，所以可以 1L -&gt; next -&gt; next = L; 再让原本4结点的后继指向NULL，也就是反序后新链表的表尾，同时破除了两节点的环。 1L -&gt; next = NULL; 这样一个5(NewL)-&gt;4(L)-&gt;NULL 的链表就形成了。 实现所以递归法的代码就是： 1234567LinkList In_reverse(LinkList L){ if(L == NULL || L -&gt; next == NULL) return; LinkList NewL = In_reverse(L -&gt; next); L -&gt; next -&gt; next = L; L -&gt; next = NULL;} 代码结束了，递归的回退过程还在进行，继续探讨这个过程，此时函数回退到L遍历到3结点的时候，因为第4行已经执行过了，所以从第五行开始。 和刚才一样我们让3结点的后继指向自己，同时自己指向NULL，现在得到了新的链表5(NewL)-&gt;4-&gt;3(L)-&gt;NULL 递归继续回退到L=2时候，得到新的链表5(NewL)-&gt;4-&gt;3-&gt;2(L)-&gt;NULL 终于函数回退到了它递归开始的时候 ，此时L = 1，（注意：对于带有头结点的单链表在传入时应该是其第一个元素而不是空数据域的头结点），其他操作还是和之前一样，最终我们就得到了原单链表的反序链表5(NewL)-&gt;4-&gt;3-&gt;2-&gt;1(L)-&gt;NULL 细节前面我们提到在传入带有头结点的单链表时候一定要是其第一个元素，而不是头结点，因为考虑如果传入的是头结点，那么当L=1执行完成后，在函数递归回退过程中还存在L为头结点的时候，同样也会让一个没有数据域的头结点加到了反序的单向链表中，中间出现无关结点并不是我们希望的。 对于存在头结点的单链表在函数的调用时候传入其后继，同时因为反序后的链表没有头节点，所以让原单链表的头结点指向反序后的首元素即可。原来适用于带头结点的遍历函数同样适用。 1234567int main(void){ ... L -&gt; next = In_reverse(L -&gt; next); //带有头结点的链表需要传入其第一个元素// L = In_reverse(L); 没有头结点的链表反转 display(L); //接收带头结点的单链表进行遍历 ...} 结尾至此关于单链表反序的两种方法迭代法和递归法就介绍完了，仔细想想虽然简单但其背后的逻辑确实精美巧妙，每次理解完前人写得经典算法总是会不由得感慨他们实在是聪明，解决抽象问题就像计算机思维一样思考。 If I have seen further, it is by standing on the shoulders of giants. Isaac Newton 2019.10.23AsahiHuang","link":"/单向链表的反转-递归法/"},{"title":"Thinkpad-P51-Hackintosh","text":"EFI针对本机型在GitHub上传过一个EFI针对10.14.2https://github.com/AsahiHuang/ThinkPadP51-Hackintosh 目前已经更新到10.14.6，更新前注意更新clover版本，老版本alc睡眠唤醒会造成无声，请更新lilu组建，详细方法见上面链接 配置本机的主要配置信息： 设备 描述 CPU i7-7700HQ 显卡 HD630 屏幕 4k（京东方） 内存 16G 硬盘 sm961 注意如果你的机型和我差不多的话最方便的办法把下载的镜像写入u盘后直接替换我的EFI文件，注意包括序列号在内的SMBIOS信息已移除自行修改 至于说原生网卡的好处，配合aw解锁啦 更新 2019.10.7 更新 版本升级到10.15 完美支持sidecar AsahiHuang","link":"/Thinkpad-P51-Hackintosh/"},{"title":"用 oneindex 作图床","text":"写文章最麻烦的莫过于图片的管理和插入了，一个好的图床工具能减轻不少负担，本着勤俭节约（qiong）的原则，想找个免费的图床。 之前使用的 ipic+ 微博图床，虽免费好用，只是用了几次就挂了好几张。有考虑过用七牛云，免费10G空间，不过 https 不计入免费流量，后来因为个人版的 ondrive 送的30G要满了，加了个家庭车群想上车，这时候了解到了oneindex。oneindex 旨在将 onedrive 部署为个人的公盘，同时还可以作为在线的图床工具，oneindex 内容的访问不计入vps的带宽，自带的图床工具简单好用，提供了三种引用格式。比不上ipic拖拽复制方便但也足够实用了(本文所有图片都来自 oneindex 的图床)，只是国内加载速度慢了点。 我的 oneindex 地址: https://pan.asahih.com/ 具体的部署方法参考：http://blog.lwc.im/2018/12/02/oneindex/ 还可以 Aria2+AriaNg 实现离线下载至 oneindex。 2019.10.7 更新 更换为免费的catbox，加载速度快 AsahiHuang2019.8.26","link":"/用 oneindex 作图床/"},{"title":"难受的一天","text":"​ 今天持续了许久晴空开始变得阴沉，一大早起来在车站等待教练开车带去考场，一路上教练重复着一个个项目的操作细节和步骤，我已经认为对这些轻车熟路，不过是去考场再做一遍。如果真的那么顺利当然也不会出现这样的标题了。 ​ 考试的时间可能半个小时都不到，但等待时间却足足花了半天，我从八点多进入考场一直等到两点才轮到我。因为进博会关系周一周二不安排考试，所以周三考试的人特别多。而且中途还出现了网络故障所有考生的考试都暂停了。等待的过程十分煎熬，一方面想早点结束，另一方面心中充满着的不安与焦虑。脑海中反复地问自己如果熄火了怎么办，如果入库车头没进线怎么办等等等自己曾经遭遇的。结果到了考试过程这些情况没碰到，却死在了坡道上了。第一次上坡害怕车右边压线，稍微打了点方向，结果上去停住直接报超过50厘米考试不合格。没办法重来一圈吧，第二次对牢了点上坡，加上速度放的有点快了，刹车，停车点在前面，考试关掉了。失望，难受，沮丧，缓缓的下坡只能继续练习练习后面的项目。 ​ 出来后告诉教练考试挂了，教练反复讲不是都和你讲过的吗。教练一直说管住离合就好了。。。其实我觉得我挂科原因是没有管住自己的腿。我一上车腿就不停地抖，加上考试失败后的心态，再次证明自己的心理素质是多么差。这些心理问题在驾考上暴露无疑。离开考场后看到离场考生有沮丧的，有欢喜的。我跟教练讲不用送我了，自己一个人走了条寂静小路。 ​ 生活的挫折岂止一个科目二的挂科，但如果无法从这一失败的阴影走出，往后的路只会更加艰难。 AsahiHuang2019.11.6","link":"/难受的一天/"},{"title":"西历2019小结","text":"终于本世纪的第二个十年也告一段落了。 回顾​ 首先这个 blog 也是在今年才上线的，也算是初年吧，虽然记录的内容不多，但想想以前随写得都已经不知道封存在哪块硬盘的角落里了，也就懒得写了。这么想想就相当有意义了。当然接下来日子还是得多写写，不至于像现在这样想回顾一下也没什么留下来啊。 ​ 今年比较重要的一件事就是家里迎来的一位新成员。说起来相处了快一年具体叫她什么名字还没认真考虑过，平时也就叫她咪咪吧。故事是在一天晚上我去外面丢垃圾（可能一年都不会主动去几次），看见几个邻居打着手电筒在看一棵树。我就好奇地凑上去问他们在做什么。他们说有只小猫困树上了，所以要救她下来。之后我也就没继续多停留，也没放在心上。后来有天我妈回来时候发现家门口有只小猫在转，我妈妈也是比较喜欢猫的那种，看她又瘦又可怜就把她带回了家。 ​ 打听后了解到这只猫正是那天晚上邻居们救的，一个老大爷家收养了，不过老大爷不怎么管她也没什么吃的，所以小猫经常在外面乱晃。哈哈哈这只猫极度的粘人，只要有人在她边上她就会凑过来，特别喜欢躺在人的腿上。我们家就决定收养她了。或许确实和我们家有一种缘分吧。虽然她不是什么优良的品种，只是普普通通的花猫。而且比起花大价钱购买所谓品种猫，驱使商人违背生物自然繁衍而强行配种。收养一只小生命，给予她一个家不是更有意义和价值吗。 ​ 不过，陪伴外婆的小狗老白却永远不在了。即使半年多没去，到达楼下年岁已高的他总是兴奋的跑出来摇摆着尾巴。可惜现在再也没有那个欢快的身影。老白很脏很憔悴，但年轻的时候是一户人家的宠物狗搬家后被遗弃了，可惜他的后半生可能享受不到之前的待遇。外婆家是散养他的，喂他点剩饭剩菜。虽说日子比以前苦了点，但他确实能感受到外婆对他的喜爱。当你真心喜欢他的时候，狗能做到真正的真诚回报。每天外婆买菜、跳广场的路上，他始终不离不弃跟在后面。对于外婆来说，老白的离去就像失去了一位多年的挚友，外公离世多年后，那个每天一个人出门路上，在没有那欢快的身影。 ​ 今年下半年的计划是考驾照的，国庆放完后约了驾校教练报班，不过因为周末有空加上第一次科目二太紧张挂科了（那几天郁闷的为此还写了篇）中间约考时间拖了相当久。科目三的预约时间到了明年3号。虽然计划没完成但总归也是人生中非常重要的事情，希望接下来的科目三能够顺利通过拿到本本吧。 ​ 本本拿完终极目标当然是首台车买特斯拉哈哈哈。真的是超级喜欢特斯拉这种感觉，大概因为自己是电子产品爱好者吧，至于传统车那些指标完全不care。今年也是特斯拉中国工厂在临港竣工，而且年底首批国产 model 3 已经交付了，希望未来价格能够继续降下来，让我的目标能实现吧。 2020​ 终于到了全面实现小康的一年，至少到今天还没被消灭哈哈哈。2020 有更多的事情要做，相当关键的一年。996，251，优化，淘汰，这样的词在2019年不断出现，就像2019年开年说得那样，2019将是最近五年经济形势最差的一年，但会是未来五年最好的一年。而现在的我正处在踏入这个纷繁复杂的社会中的最后一步。不要给自己留遗憾，这是2019的我所给予2020的我的忠告，期待一年之后回过头来，或许更长时间？自己能够真正走正确的路。​ AsahiHuang2019.12.31 晚","link":"/西历2019小结/"},{"title":"誓言的终章","text":"终于补完了去年上映后期待已久的京吹剧场版誓言的终章，同时还是白箱剧场版首映，(╯﹏╰）估计要看到一样得等一年了。 终章京吹系列动画除了几部总集篇和利兹与青鸟以外，誓言的终章算是第一部剧场版。可以说这次剧场版在原本高水准的TV系列基础上有了更近一步的提升。京吹系列包含大量的演奏画面，而京都这次加入了实时的乐谱。不过京吹从来不是一个单纯的音乐番。像我这样对音乐一窍不通的的京吹也喜欢看京吹。看过TV系列的都知道，故事中吹奏部，可爱的女高中生都是动画的载体，青春一直是京吹的主旋律。就如明日香学姐说，社团和恋爱才是青春嘛。 京阿尼在细节上相当重视，所以大家都夸京阿尼细腻，其中推主@Trumpet_0515提到一个演出细节 大致意思就是糖分会对乐器产生损害，所以丽奈在吃完橘子糖之后喝了口水，再吹奏。哈哈哈如果没相关经验的，大概很难看出这种细节。 京阿尼对青春感觉的把握一直是非常老道。京吹系列的导演山田尚子非常注重动作演出（还是个腿控）。其作品充满了大量专业手法的镜头运用。我一个非专业人士也就看个热闹吧，但这并不影响我们观众感知一些场景所带来的感受。比如开头的场景久美子在看到一年级学妹偷偷看她演奏的时候以为她是有意向加入社团的，但当得知对方还没想好后又失落地退了回去。连贯的动作演出相比于只给脸部表情和话语上的变化更能表现少女当时的情感变化而不是一个只是在念台词的演员。（黄大叔触发了久石奏线） 两人洗手的场景被新角色美铃吐槽是不是靠的太近了（毕竟新来的，社团其他成员估计对这两人已经见怪不怪了），很显然这里就是想着重强调一下美铃这个角色内心的封闭，她无法接受被人亲密地叫小美，自然就无法理解为什么两个女孩能走的这么近。同时也在映射着另一个角色的内心，也是这部除了黄大叔外最重要的角色久石奏。 如何让一个新角色承担接替之前动画的女主丽奈（黄大叔算男主），京吹给出的答案就是创造第二个丽奈。但与丽奈不同的是，久石奏的内心活动更为复杂。这与她之前的经历有关（在剧透就剧透完了）。久美子希望她能帮助美铃加入社团之中，虽然久石奏答应了，但她实际上并没有怎么做（这段旋转镜头非常赞）。因为她知道美铃之所以排斥社团活动原因，其实她们都是同一类人，都是不断努力，旁人能够看出她们相比于彩月和夏纪能力上更优秀，但却又害怕因为同学中的关系让自己努力变得徒劳而被疏远。而丽奈的直率性格与久石奏形成鲜明对比。 所以久石奏相当直接地问黄大叔喜欢彩月还是美铃，在是试探对于低音组的三人中，夏纪学姐和她更喜欢谁。她知道久美子注意到自己比夏纪学姐更优秀，所以大树和镜头前的铁网预示着两人间的隔阂，不仅仅是当前的对话，还有两人内心的想法，她期待久美子认可她。后来两人雨中狂奔我们知道，久石奏害怕努力后的徒劳，努力到底是为了什么。而久美子并不在乎这些，对她来说吹好上低音号就足够了，这种与TV初期那个选上低音号都在犹豫的久美子完全不同的内心变化正是丽奈所影响的。 最后，大巴上，虽然久石奏说到头来还不是一场空，但当久美子问久石奏不甘心吗，久石奏哭着说不甘心的要死。哈哈哈熟悉吧，正是初中时候那段只有丽奈不甘心地哭再现。但这种不甘与久石奏初中时候经历完全不同，北宇治的这次失败给予她“继续吹好”的动力，而不再是影响吹奏的猜忌和对努力后徒劳的害怕，我想这也是京吹系列一直以来所想要告诉我们的。 新系列结尾短视频我们的黄大叔成了社团部长，京都计划还有一部TV系列，是剧场版后续的故事，通过一系列的动画中久美子以及围绕她的角色成长过程，让京吹中的角色塑造更加丰满，期待京阿尼再次带给我们这份青春的旋律。不过因为去年纵火案的关系，新TV虽说已经制作中，不过最近还没什么消息。本人在这里非常感谢所有staff们努力付出，也对因为纵火去世的京阿尼员工再次表示哀悼。他们就像白箱TV最后喵森所讲的那样“一直像这样去照亮别人的心房”。 &nbsp; &nbsp; そして,次の曲が始まるのです.","link":"/誓言的终章/"}],"tags":[{"name":"纪念日","slug":"纪念日","link":"/tags/纪念日/"},{"name":"铁道","slug":"铁道","link":"/tags/铁道/"},{"name":"黑苹果","slug":"黑苹果","link":"/tags/黑苹果/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"ACG","slug":"ACG","link":"/tags/ACG/"},{"name":"栈","slug":"栈","link":"/tags/栈/"},{"name":"数据结构","slug":"数据结构","link":"/tags/数据结构/"},{"name":"leetcode","slug":"leetcode","link":"/tags/leetcode/"},{"name":"单链表","slug":"单链表","link":"/tags/单链表/"},{"name":"随笔","slug":"随笔","link":"/tags/随笔/"},{"name":"算法","slug":"算法","link":"/tags/算法/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"oneindex","slug":"oneindex","link":"/tags/oneindex/"}],"categories":[{"name":"生活","slug":"生活","link":"/categories/生活/"},{"name":"leetcode","slug":"leetcode","link":"/categories/leetcode/"},{"name":"笔记","slug":"笔记","link":"/categories/笔记/"}]}