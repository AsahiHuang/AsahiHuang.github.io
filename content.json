{"pages":[{"title":"About","text":"我感觉现在，离自己的梦想又近一步了！ 我&emsp;&emsp;现在是21岁的我。这20年里我与他人一样，学会了说话，学会了走路，学会了喜爱，学会了思考。许多人包括我在内都会厌恶昨天的自己，无知与幼稚。这是成长过程，或许十年后再来看学生时代会更加厌恶那时的自己吧。 &emsp;&emsp;生活中我能够意识到我的亲友，我的朋友他们对我的关怀与帮助。但我是一个很自私的人，因为我所表现的就是一在的索取，但真正轮到我付出却少之又少。我一直在想我欠他们太多了，或是我辜负他们了。其实那些真正爱你的人并不是想要得到所谓的回报，对于他们所表露出的真正的情感我却难以处理。所以我更倾向豪猪的哲学，寒冷的冬天，一群豪猪挤到一起取暖，但各自身上的刺迫使它们马上分开；御寒的本能使它们又聚到一起，疼痛则使它们再次分开。这样经过几次反复，它们终于找到了相隔的最佳距离，在最轻的疼痛下得到最大的温暖，只能自己蜷缩在一起，不用顾及他人。很明显这是一种逃避，就像我的高中语文老师指着我说的一个毫无责任感的人。 &emsp;&emsp;人是个很神奇的生物，我们继承了猴子的基因，猴子的手，但不知为什么，我们拥有了一个能够让我们理解理性与感性的大脑，同时却又拥有这不同的思维与性格。 目的&emsp;&emsp;这个 Blog 创建的目的是想记录自己学习新技术的过程，同时会夹带一些随笔或者自己喜欢的ACG圈的事情，毕竟文学功底不强写雅文什么的没这个水平。首先这些文章写完后是想展示给大家，因为技术水平不高，大佬什么完全不会care，但更多的其实是想写给自己。在学习的过程有了新的收获如果只是单纯作为一份笔记写下来，存在某个地方，可能不久就忘了放哪或者很少再想去回顾了。而将这种收获放在博客上给大家看时，即使可能根本没人关注，但自己也会更加细心处理其中细节，产出比随手的笔记更有价值的文章。当然最重要的还是能够坚持写下去啦。 理想&emsp;&emsp;从事开发工作。曾经有个学长问我你们想做开发的是不是都想赚很多钱，我当时回答至少我不是，他继续问那你是为了什么，去考个公务员或者教师或许更稳定舒服，我说我想去创造，这是我的理想。教资或者公务员或许是个不错选择，而且我不知道如果将理想变为工作会不会转为失望，但我认为从事一个自己毫无兴趣的事情只会永远无聊。活着当然是首要目标，只是我不想压抑的活着。 &emsp;&emsp;前几天参加了一位决心要带起我们学校ACM的老师举办的算法比赛，在座的很多大一新生，羡慕之情油然而生。因为他们意识到学习的重要性，并且还有更多时间在校园，回看自己却浪费了太多时间。但我相信至少努力了还是会有收获的，不努力终究一无所得。最后希望自己能始终明白，当才华支撑起自己理想时候，请安静地学习。 终。 2019.10.31Asahi Huang ​","link":"/about/index.html"},{"title":"categories","text":"","link":"/categories/index.html"}],"posts":[{"title":"git常用指令","text":"初始配置1234git config --global user.name &quot;username&quot;git config --global user.email &quot;email&quot;--global参数可以保证机器上所有的git仓库使用这个配置 然后输入 1ssh-keygen 分支 查看分支：git branch 创建分支：git branch name 切换分支：git checkout name 创建+切换分支：git checkout –b name 合并某分支到当前分支：git merge name 删除分支：git branch –d name 远程仓库(github) 创建ssh key github上add ssh key github上创建新的仓库 根据GitHub仓库链接 1git remote add origin https://github.com/AsahiHuang/Data_Structure.git 将本地仓库推送到远程仓库 ,git push,实际将当前分支推送到远程 由于远程库是空的，我们第一次推送master分支时，加上了 –u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。 现在,只要本地作提交,可通过 1git push origin master 把本地master分支的最新修改推送到GitHub 文件修改回退1git reset –hard HEAD~100 指向上次修改的指针 或者 1git checkout -- filename 把filename文件在工作区的修改全部撤销 这里有两种情况 文件自动修改后，还没有放到暂存区，使用 撤销修改就回到和版本库一模一样的状态。 另外一种是文件已经放入暂存区了，接着又作了修改，撤销修改就回到添加暂存区后的状态。 再没有commit前,通过此命令也可将删除的文件(rm filename)恢复 远程仓库克隆1git clone 远程仓库地址 即可在本地生成一个版本库 分支策略​ 常合并分支时，git一般使用”Fast forward”模式，在这种模式下，删除分支后，会丢掉分支信息，现在我们来使用带参数 –no-ff来禁用”Fast forward”模式 1git merge –-no-ff -m &quot;注释&quot; 合并分支 分支策略：首先master主分支应该是非常稳定的，也就是用来发布新版本，一般情况下不允许在上面干活，干活一般情况下在新建的dev分支上干活，干完后，比如上要发布，或者说dev分支代码稳定后可以合并到主分支master上来。 bug分支​ 在开发中，会经常碰到bug问题，那么有了bug就需要修复，在Git中，分支是很强大的，每个bug都可以通过一个临时分支来修复，修复完成后，合并分支，然后将临时的分支删除掉。比如我在开发中接到一个404 bug时候，我们可以创建一个404分支来修复它，但是当前的dev分支上的工作到一半还没有提交,此时无法切换分支. ​ Git提供了stash 功能,可以把当前的工作现场隐藏,等恢复现场后继续工作 1git stash 此时工作区的状态时干净的 切换回主分支,新建一个临时分支,修复完成后,回到主分支并合并,删除临时分支 现在回到dev分支 此时工作区时干净的,可通过 1git stash list 查看, Git把stash内容存在某个地方了，但是需要恢复一下,两种办法: git stash apply恢复，恢复后，stash内容并不删除，你需要使用命令git stash drop来删除 另一种方式是使用git stash pop,恢复的同时把stash内容也删除了。 历史 查看日志 1git log 修改日志 最近一次commit的修改: 1git commit --amend","link":"/git 常用指令/"},{"title":"Thinkpad-P51-Hackintosh","text":"针对本机型在GitHub上传过一个EFI针对10.14.2https://github.com/AsahiHuang/ThinkPadP51-Hackintosh 目前已经更新到10.14.6，更新前注意更新clover版本，老版本alc睡眠唤醒会造成无声，请更新lilu组建，详细方法见上面链接 本机的主要配置信息： 设备 描述 CPU i7-7700HQ 显卡 HD630 屏幕 4k（京东方） 内存 16G 硬盘 sm961 如果你的机型和我差不多的话最方便的办法把下载的镜像写入u盘后直接替换我的EFI文件，注意包括序列号在内的SMBIOS信息已移除自行修改 至于说原生网卡的好处，配合aw解锁啦","link":"/Thinkpad-P51-Hackintosh/"},{"title":"单向链表的反转(递归法)","text":"上次讲了通过迭代法 的方式，新建一个NewL倒叙插入原链表结点来实现反转，这次来讲递归法。 首先，什么是递归，去Google搜递归，会得到一个“你是不是要找递归”的提示，点开后还是这个页面。这就是递归。递归简单说就是函数调用自己。递归思想类似与栈，后入先出。这里重点讲讲递归实现单向链表的过程。 我们还是以这样一个五个元素的单链表为例，注意和之前一样演示的链表包含一个头结点L 1234567//链表的结构typedef struct Node{ int date; struct Node * next;} Node;typedef Node * LinkList; 递归递归需要出口，回想斐波拉契数列递归实现，我们的出口是当数字n==1 || n ==2 时，return 1;结束。对于一个单向链表来说，遍历到末尾NULL就是终点，同时考虑空表的情况，所以我们就有了递归的出口： 12345LinkList In_reverse(LinkList L){ if(L == NULL || L -&gt; next == NULL) return; ...} 递归的问题规模需要逐渐缩小，我们设置递归的前进条件，也就是遍历链表，新建一个新的头结点指针 NewL 让他等于递归结果。 12345... if(L == NULL || L -&gt; next == NULL) return; LinkList NewL = In_reverse(L -&gt; next);... 根据递归的出口条件，当 L -&gt; next == NULL时候返回，此时L就在5的位置，姑且称他为L=5的时候(而不是L指向5这个结点,指向5结点的是其前继4）。同时在递归结束前NewL也等于5，也就是说此时L，NewL都在最末尾的结点。同时因为递归调用已经结束，所以在接下来递归回退的过程中 LinkList NewL = In_reverse(L -&gt; next) 不会再执行，NewL始终留在原链表的最后结点。 既然递归结束了就要开始退回，根据后进先出的原则，首先回到的是L = 4的时候，开始执行递归调用后的代码 所以我们需要做什么？我们希望的结果是逆序原来的链表，现在的情况是我们创建的NewL已经牢牢地呆在原链表的最末尾也就最后新链表的开始，这正是我们想要的，所以我们只需要让4结点和5结点反一下指向不就实现了逆序。 为了实现反序，让后继的后继等于我，此时4结点和5结点是成环状态，互相指向对方。 代码实现上我们让5结点的next指向L，5结点也是4结点（同时也是现在的L）的后继，所以可以 1L -&gt; next -&gt; next = L; 再让原本4结点的后继指向NULL，也就是反序后新链表的表尾，同时破除了两节点的环。 1L -&gt; next = NULL; 这样一个5(NewL)-&gt;4(L)-&gt;NULL 的链表就形成了。 实现所以递归法的代码就是： 1234567LinkList In_reverse(LinkList L){ if(L == NULL || L -&gt; next == NULL) return; LinkList NewL = In_reverse(L -&gt; next); L -&gt; next -&gt; next = L; L -&gt; next = NULL;} 代码结束了，递归的回退过程还在进行，继续探讨这个过程，此时函数回退到L遍历到3结点的时候，因为第4行已经执行过了，所以从第五行开始。 和刚才一样我们让3结点的后继指向自己，同时自己指向NULL，现在得到了新的链表5(NewL)-&gt;4-&gt;3(L)-&gt;NULL 递归继续回退到L=2时候，得到新的链表5(NewL)-&gt;4-&gt;3-&gt;2(L)-&gt;NULL 终于函数回退到了它递归开始的时候 ，此时L = 1，（注意：对于带有头结点的单链表在传入时应该是其第一个元素而不是空数据域的头结点），其他操作还是和之前一样，最终我们就得到了原单链表的反序链表5(NewL)-&gt;4-&gt;3-&gt;2-&gt;1(L)-&gt;NULL 细节前面我们提到在传入带有头结点的单链表时候一定要是其第一个元素，而不是头结点，因为考虑如果传入的是头结点，那么当L=1执行完成后，在函数递归回退过程中还存在L为头结点的时候，同样也会让一个没有数据域的头结点加到了反序的单向链表中，中间出现无关结点并不是我们希望的。 对于存在头结点的单链表在函数的调用时候传入其后继，同时因为反序后的链表没有头节点，所以让原单链表的头结点指向反序后的首元素即可。原来适用于带头结点的遍历函数同样适用。 1234567int main(void){ ... L -&gt; next = In_reverse(L -&gt; next); //带有头结点的链表需要传入其第一个元素// L = In_reverse(L); 没有头结点的链表反转 display(L); //接收带头结点的单链表进行遍历 ...} 结尾至此关于单链表反序的两种方法迭代法和递归法就介绍完了，仔细想想虽然简单但其背后的逻辑确实精美巧妙，每次理解完前人写得经典算法总是会不由得感慨他们实在是聪明，解决抽象问题就像计算机思维一样思考。 If I have seen further, it is by standing on the shoulders of giants. Isaac Newton 2019.10.23AsahiHuang","link":"/单向链表的反转-递归法/"},{"title":"eva2020","text":"EVA 2020新剧场版 0706特别活动 EVA 2020年新剧场版 AVANT1 0706版将在2019.7.6首发 有意思的是,这一时间点正好与飞跃巅峰的结尾0706呼应","link":"/eva2020/"},{"title":"单向链表的反转","text":"对单向链表的反转是非常经典的算法题，链表不同于数组，节点的遍历需要每个节点逐个访问下去。理解反转的过程能对线性表的链式存储结构有个充分的认识。为了方便理解（也为了防止自己日后忘了）所以尽可能仔细的记录其过程。 建表首先定义链表结构： 123456typedef struct Node{ int date; struct Node * next;} Node;typedef Node * LinkList; 创建一个链表 12345678910111213141516171819202122232425262728//n 描述了数据数组长度//尾插法LinkList creatListTail(LinkList L,int a[], int n){ LinkList p,r; L = (LinkList)malloc(sizeof(Node)); r = L; for (int i = 0 ; i &lt; n ;i++){ p = (LinkList)malloc(sizeof(Node)); p -&gt; date = a[i]; r -&gt; next = p; r = p; } r -&gt;next = NULL; return L;}//头插法LinkList creatListHead(LinkList L,int a[] ,int n){ LinkList p; L = (LinkList)malloc(sizeof(Node)); L -&gt; next = NULL; for (int i = 0; i &lt; n; i++){ p = (LinkList)malloc(sizeof(Node)); p -&gt;date = a[i]; p -&gt; next = L -&gt;next; L-&gt;next = p; } return L;} 一定要注意自己的建表方法，因为尾插法插入是按照数据顺序建表的，而头插法则是逆序。如果你没注意到而用头插法顺序插入数据然后反转当然又变成了顺序了。为了演示这边使用的是尾插法。同时补上头插法的代码，因为头插法的思想在这里非常重要 我们以一个长度为5数组来演示： 1a[5] = {1,2,3,4,5}; 我们得到了一个以L为头指针，包含了五个节点的单向链表 反转迭代法把这条链表想象成一个字符串，如果让你逆序一个字符串”Hello World”，你会怎么做？除了对半交换外，还有个方法是创建一个新的空间然后逆序存放原字符串的每个字符。 我们也是这样，首先创建一个新的头节点 ，就叫它 NewL。让他的后继节点为NULL，是不是有点像头插法建表步骤， 同时新建一个p指针指向L表的第一个节点，也就是p = L -&gt; next。 现在我们可以让 p -&gt; next指向 NewL？ 不可以，不同于头插法那时我们一直在生成新的p节点，现在如果直接让 p 的下一节点指向新的表尾，那我们就丢失了L表中 p -&gt; next，也就是p后继节点的位置，我们就没法遍历接下来的L表了，所以我们需要创建一个temp 来暂时存放p的后继节点，等到 p 也就是当前节点添加到新表完成后再让p回到temp继续。 我们先创建一个节点指针temp，让temp=p-&gt;next存储p的后继节点信息 接着我们就可以放心地让p指向新表的表尾（表尾是因为此时NewL还只是NULL） 12temp = p -&gt; next; //让temp存放p后驱节点p - &gt; next = NewL -&gt; next; //让p指向当前新表的后继 我们完成了一个节点的插入到新表，接下来我们要准备后续节点。首先我们让 NewL -&gt; next = p 从而使接下来的节点始终插入在新表头指针后面，如果你了解头插法你就会发现这一过程极其相似，为了实现逆序我们就是以原来的L表用头插法来创建一个新表，头插法本身就是逆置建表，让p回到temp后进入下次循环，新节点会不断的插入在表头后，直到L表结束。 12345//头插法部分：... p -&gt; next = L -&gt;next; //头插入中我们让新节点的后继指向头节点的后继 L-&gt;next = p //然后让头节点的后继变成新节点从而在中间不断插入... 12345//迭代法部分：... p -&gt;next = NewL -&gt; next; NewL -&gt; next = p;... NewL 头指针后继指向p（新插入节点） p移动到temp位置回来原表，准备下次循环直到NULL 代码实现： 12345678910111213141516LinkList reverse(LinkList L){ if (L == NULL || L -&gt; next == NULL){ return L; } LinkList p = L -&gt; next; LinkList NewL = (LinkList)malloc(sizeof(Node)); NewL -&gt; next = NULL; LinkList temp; while(p != NULL){ temp = p-&gt;next; p -&gt;next = NewL -&gt; next; NewL -&gt; next = p; p = temp; } return NewL;} 显示链表，注意这里链表都是有头节点 12345678910void display(LinkList L){ LinkList p; //指向第一个节点 p = L -&gt; next; while (p != NULL) { printf(\"%d\\n\",p-&gt;date); p = p -&gt; next; } } 基本上就是迭代法实现单链表反转的过程。 后面会再讲讲还有一种方法递归法。","link":"/单向链表的反转/"},{"title":"夕阳无限好","text":"台风“利奇马”离开上海后南汇的夕阳 AsahiHuang2019.8.11南汇","link":"/夕阳无限好/"},{"title":"摩尔投票算法","text":"起因刷leetcode_169 数组tag的时候有道题 给定一个大小为 n 的数组，找到其中的众数。众数是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。 你可以假设数组是非空的，并且给定的数组总是存在众数。 一般来讲大概第一反应是暴力算法,出现次数累加看谁超过了总数量的一半即可输出结果…方法可行可惜效率太低,时间复杂度达到O(n^2^),那有没有线性复杂度的解决办法. Boyer-Moore 投票算法少数服从多数的摩尔投票算法就是其中之一的解决之道 这里按照找众数的题来解释算法的实现过程: 1nums:[1,1,2,1,2,2,2,1,2] 比如说该数组nums,显然众数是 2 首先我们设置一个候选众数,初始为第一个元素nums[0] 我们设置一个计数器count,初始值为1,其规则是遇到与候选众数相同的数是+1,不同-1 当count值为0时,我们让候选众数变为下一位,并将count重置为1,继续上述规则 1[1,1,2,1,2 | 2,1,2] 分隔处为count归0时,此时候选众数变为下一位2,count值回到1 显然在这前面这一过程中,随着count值的递增递减到归0我们消耗了相同数量的非众数和众数 这是我认为投票算法最重要的思想,通过这样的往复,遍历结束后,最终候选众数即为该数组众数 代码实现附上用C实现上述例子: 1234567891011int majorityElement(int* nums, int numsSize){ int count = 0,res = nums[0]; int i = 0; while(i &lt; numsSize){ if (!count) res = nums[i]; count += (nums[i] == res ? 1:-1); i++; } return res;} AsahiHuang2019.7.5 at 530","link":"/摩尔投票算法/"},{"title":"用hexo写博客","text":"安装1$ npm install -g hexo 在git bush中安装hexo 初始化新建一个hexo文件夹,用来存放所有代码. 1$ hexo init //初始化 hexo 会自动下载需要文件. 12hexo g //生成hexo s //启动本地服务 打开浏览器访问 http://localhost:4000 即可看到内容 修改主题​ 找到官方主题:https://hexo.io/themes/ 下载到hexo目录的theme文件下 1git clone #主题仓库地址* /theme 修改根目录的_config.yml 中的 theme: landsape 改为 *theme: #NewThemeName# * 如果出现莫名其妙问题可通过*hexo clean *来清理,在生成并发布 上传到GitHub1$ hexo d 首先,ssh key配置好,其次,配置_config.yml中有关deploy的部门: 1234deploy: type: git repository: git@github.com:#githubID#/#githubID#.github.io.git branch: master #内为替换内容,也就是你的GitHub用户名 其次还需要在git bash输入 1npm install hexo-deployer-git --save 现在输入*hexo d * 就会将本次有改动的代码全部提交,没有改动的不会 提交完成后原仓库内的文件都没了,存放在了source文件夹. 常用hexo 命令1234567hexo new &quot;postName&quot; #新建文章hexo new page &quot;pageName&quot; #新建页面hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server）hexo deploy #部署到GitHubhexo help # 查看帮助hexo version #查看Hexo的版本 1234hexo n == hexo newhexo g == hexo generatehexo s == hexo serverhexo d == hexo deploy 12hexo s -g #生成并本地预览hexo d -g #生成并上传 写博客在git bash定位到hexo的根目录 1$ hexo new &apos;my-first-blog&apos; hexo就会在*_posts *下生成相关的md文件,然后再markdown编辑器上编写 一般完整的格式: 123456789---title: postName #文章页面上的显示名称，一般是中文date: 2013-12-02 15:30:16 #文章生成时间，一般不改，当然也可以任意修改categories: 默认分类 #分类tags: [tag1,tag2,tag3] #文章标签，可空，多标签请用格式，注意:后面有个空格description: 附加一段文章摘要，字数最好在140字以内，会出现在meta的description里面---以下是正文 让博文列表不显示全部内容默认情况下,生成的目录会显示全部的文章内容,可以再合适的位置加上 1&lt;!--more--&gt; 即可 参考:https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html#%E4%BD%BF%E7%94%A8hexo%E5%86%99%E5%8D%9A%E5%AE%A2","link":"/用 hexo 写博客/"},{"title":"对于京都动画的不幸沉痛的悼念","text":"@AsahiHuang最後まで笑ってる強さをもう知っていた， もう泣かない…，もう泣かない…。感谢京阿尼，一切都会安好的 这已经不仅仅对于动画业界而言的一次沉痛灾难,我们失去了那么多用自己的心血和热情塑造一个个梦想的人，如今只能满怀悲痛的心为他们致以敬意，祝福每一位经历这场不幸的幸存者们早日康复，回到自己的幸福。 我相信京都动画一定能挺过这段艰难并继续将自己的优秀作品带给大家. AsahiHuang2019.7.24","link":"/对于京都动画的不幸沉痛的悼念/"},{"title":"用 oneindex 作图床","text":"写文章最麻烦的莫过于图片的管理和插入了，一个好的图床工具能减轻不少负担，本着勤俭节约（qiong）的原则，想找个免费的图床。 之前使用的 ipic+ 微博图床，虽免费好用，只是用了几次就挂了好几张。有考虑过用七牛云，免费10G空间，不过 https 不计入免费流量，后来因为个人版的 ondrive 送的30G要满了，加了个家庭车群想上车，这时候了解到了oneindex。oneindex 旨在将 onedrive 部署为个人的公盘，同时还可以作为在线的图床工具，oneindex 内容的访问不计入vps的带宽，自带的图床工具简单好用，提供了三种引用格式。比不上ipic拖拽复制方便但也足够实用了(本文所有图片都来自 oneindex 的图床)，只是国内加载速度慢了点。 我的 oneindex 地址: https://pan.asahih.com/ 具体的部署方法参考：http://blog.lwc.im/2018/12/02/oneindex/ 还可以 Aria2+AriaNg 实现离线下载至 oneindex。 AsahiHuang2019.8.26","link":"/用 oneindex 作图床/"}],"tags":[{"name":"git","slug":"git","link":"/tags/git/"},{"name":"黑苹果","slug":"黑苹果","link":"/tags/黑苹果/"},{"name":"单链表","slug":"单链表","link":"/tags/单链表/"},{"name":"数据结构","slug":"数据结构","link":"/tags/数据结构/"},{"name":"ACG","slug":"ACG","link":"/tags/ACG/"},{"name":"随笔","slug":"随笔","link":"/tags/随笔/"},{"name":"算法","slug":"算法","link":"/tags/算法/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"oneindex","slug":"oneindex","link":"/tags/oneindex/"}],"categories":[{"name":"笔记","slug":"笔记","link":"/categories/笔记/"},{"name":"生活","slug":"生活","link":"/categories/生活/"}]}